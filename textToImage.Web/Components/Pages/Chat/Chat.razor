@page "/"
@using System.ComponentModel
@using System.Runtime.InteropServices
@using System.Text.RegularExpressions
@using textToImage.Web.Services.Images
@inject IChatClient ChatClient
@inject IHttpClientFactory HttpClientFactory
@inject ITextToImageClient ImageClient
@inject NavigationManager Nav
@inject SemanticSearch Search
@inject IImageCacheService ImageCache
@implements IDisposable

<PageTitle>Chat</PageTitle>

<ChatHeader OnNewChat="@ResetConversationAsync" />

<ChatMessageList Messages="@messages" InProgressMessage="@currentResponseMessage">
    <NoMessagesContent>
        <div>To get started, try asking about these example documents. You can replace these with your own data and replace this message.</div>
        <ChatCitation File="Example_Emergency_Survival_Kit.pdf"/>
        <ChatCitation File="Example_GPS_Watch.pdf"/>
    </NoMessagesContent>
</ChatMessageList>

<div class="chat-container">
    <ChatSuggestions OnSelected="@AddUserMessageAsync" @ref="@chatSuggestions" />
    <ChatInput OnSend="@AddUserMessageAsync" @ref="@chatInput" />
    <SurveyPrompt /> @* Remove this line to eliminate the template survey message *@
</div>

@code {
    private const string SystemPrompt = @"
        You are an assistant who answers questions about information you retrieve.
        Do not answer questions about anything else.
        Use only simple markdown to format your responses.  
        When sharing images use image links in the following format: ![image description](image-url).

        Use the search tool to find relevant information. When you do this, end your
        reply with citations in the special XML format:

        <citation filename='string' page_number='number'>exact quote here</citation>

        Always include the citation in your response if there are results.

        The quote must be max 5 words, taken word-for-word from the search result, and is the basis for why the citation is relevant.
        Don't refer to the presence of citations; just emit these tags right at the end, with no surrounding text.
        ";

    private readonly ChatOptions chatOptions = new();
    private readonly List<ChatMessage> messages = new();
    private CancellationTokenSource? currentResponseCancellation;
    private ChatMessage? currentResponseMessage;
    private ChatInput? chatInput;
    private ChatSuggestions? chatSuggestions;
    private HttpClient? httpClient;

    protected override void OnInitialized()
    {
        messages.Add(new(ChatRole.System, SystemPrompt));
        chatOptions.Tools = 
        [
            AIFunctionFactory.Create(SearchAsync),
            new ImageGenerationTool(new TextToImageOptions()
            {
                ModelId = "gpt-image-01"                
            })
        // AIFunctionFactory.Create(GenerateImagesAsync),
        // AIFunctionFactory.Create(EditImageAsync)
        ];
        httpClient = HttpClientFactory.CreateClient();
    }

    private async Task AddUserMessageAsync(ChatMessage userMessage)
    {
        CancelAnyCurrentResponse();

        // Add the user message to the conversation
        messages.Add(userMessage);
        chatSuggestions?.Clear();
        await chatInput!.FocusAsync();

        var response = await ChatClient.GetResponseAsync([.. messages], chatOptions, CancellationToken.None);
        await CacheImages(response);
        messages.AddMessages(response);
#if false
        // Stream and display a new response from the IChatClient
        var responseText = new TextContent("");
        currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);
        currentResponseCancellation = new();

        responseText.Text += response.Text;
        ChatMessageItem.NotifyChanged(currentResponseMessage);
        await foreach (var update in ChatClient.GetStreamingResponseAsync([.. messages], chatOptions, currentResponseCancellation.Token))
        {
            messages.AddMessages(update, filter: c => c is not TextContent);
            responseText.Text += update.Text;
            ChatMessageItem.NotifyChanged(currentResponseMessage);
        }

        // Store the final response in the conversation, and begin getting suggestions
        messages.Add(currentResponseMessage!);
        currentResponseMessage = null;
    #endif
        chatSuggestions?.Update(messages);
    }

    private void CancelAnyCurrentResponse()
    {
        // If a response was cancelled while streaming, include it in the conversation so it's not lost
        if (currentResponseMessage is not null)
        {
            messages.Add(currentResponseMessage);
        }

        currentResponseCancellation?.Cancel();
        currentResponseMessage = null;
    }

    private async Task ResetConversationAsync()
    {
        CancelAnyCurrentResponse();
        messages.Clear();
        messages.Add(new(ChatRole.System, SystemPrompt));
        chatSuggestions?.Clear();
        await chatInput!.FocusAsync();
    }

    [Description("Searches for information using a phrase or keyword")]
    private async Task<IEnumerable<string>> SearchAsync(
        [Description("The phrase to search for.")] string searchPhrase,
        [Description("If possible, specify the filename to search that file only. If not provided or empty, the search includes all files.")] string? filenameFilter = null)
    {
        await InvokeAsync(StateHasChanged);
        var results = await Search.SearchAsync(searchPhrase, filenameFilter, maxResults: 5);
        return results.Select(result =>
            $"<result filename=\"{result.DocumentId}\" page_number=\"{result.PageNumber}\">{result.Text}</result>");
    }

    [Description("Generates images based on a text description")]
    private async IAsyncEnumerable<AIContent> GenerateImagesAsync(
        [Description("A detailed description of the image to generate")] string prompt,
        [Description("The number of images to generate.  Some models only support generating one image at a time.")] int count = 1)
    {
        await InvokeAsync(StateHasChanged);
        var options = new TextToImageOptions()
        {
            Count = count,
        };

        var response = await ImageClient.GenerateImagesAsync(prompt, options);

        foreach(var content in response.Contents)
        {
            var cachedContent = await CacheContent(content);
            yield return cachedContent;
        }
    }

    [Description("Edits an existing image based on a text description")]
    private async IAsyncEnumerable<AIContent> EditImageAsync(
        [Description("The URL of the image to edit")] string imageUrl,
        [Description("A detailed description of the image to edit")] string prompt,
        [Description("The number of images to generate.  Some models only support generating one image at a time.")] int count = 1)
    {
        await InvokeAsync(StateHasChanged);
        var options = new TextToImageOptions()
        {
            Count = count,
        };

        DataContent dataContent;
        var cachedData = await ImageCache.GetCachedImageAsync(imageUrl);
        if (cachedData is not null)
        {
            // the image is cached, so we can use it directly
            dataContent = new DataContent(cachedData.Value.imageBytes, cachedData.Value.contentType);
        }
        else
        {
            // download the image from the URL
            var imageResponse = await httpClient!.GetAsync(imageUrl);
            var imageBytes = await imageResponse.Content.ReadAsByteArrayAsync();

            dataContent = new DataContent(imageBytes, imageResponse.Content.Headers.ContentType?.MediaType ?? "image/png");
        }

        var response = await ImageClient.EditImagesAsync([dataContent], prompt, options);

        foreach (var content in response.Contents)
        {
            var cachedContent = await CacheContent(content);
            yield return cachedContent;
        }
    }

    private async Task CacheImages(ChatResponse response)
    {
        foreach(var message in response.Messages ?? Enumerable.Empty<ChatMessage>())
        {
            Queue<string> cachedUris = new();
            foreach (var dataContent in message.Contents.OfType<DataContent>())
            {
                var bytes = MemoryMarshal.TryGetArray(dataContent.Data, out var segment)
                    ? segment.Array!
                    : dataContent.Data.ToArray();

                var cacheUri = await ImageCache.CacheImageAsync(bytes, dataContent.MediaType);

                cachedUris.Enqueue(Nav.ToAbsoluteUri(cacheUri).ToString());
            }

            foreach (var textContent in message.Contents.OfType<TextContent>())
            {
                // Find each image link in the text content and replace it with the cached URI
                // Use a regex to find image links in the format ![description](url)
                // Replace each in order of appearance
                textContent.Text = Regex.Replace(textContent.Text, 
                    @"!\[([^\]]*)\]\(([^)]+)\)", 
                    match => 
                    {
                        string url = cachedUris.Dequeue();
                        return $"![{match.Groups[1].Value}]({url})";
                    });
            }
        }
    }

    private async Task<AIContent> CacheContent(AIContent content)
    {
        if (content is DataContent dataContent)
        {
            var bytes = MemoryMarshal.TryGetArray(dataContent.Data, out var segment)
                ? segment.Array!
                : dataContent.Data.ToArray();

            var cacheUri = await ImageCache.CacheImageAsync(bytes, dataContent.MediaType);

            return new UriContent(Nav.ToAbsoluteUri(cacheUri), dataContent.MediaType);
        }
        else if (content is UriContent uriContent)
        {
            // the URI returned from the client contains a secret, download and cache the file.
            var stream = await httpClient!.GetStreamAsync(uriContent.Uri);

            var cacheUri = await ImageCache.CacheImageAsync(stream, uriContent.MediaType);

            return new UriContent(Nav.ToAbsoluteUri(cacheUri), uriContent.MediaType);
        }
        else
        {
            return content;
        }
    }

    public void Dispose()
        => currentResponseCancellation?.Cancel();
}
